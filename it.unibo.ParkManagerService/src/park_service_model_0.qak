System -msglog model

Request clientRequest : clientRequest(X) // X = in/out
Reply enter : enter(SLOTNUM) // X=0/1/2/3/4/5/6 

Request carenter : carenter(SLOTNUM)
Reply replyTokenid : replyTokenid(TOKENID)

Dispatch outTokenid : outTokenid(TOKENID)
Dispatch weightData : weightData(W) 

Dispatch move : move(X,Y)
Dispatch moveok   : move( MOVESHORT )

Context ctxparkmanager ip [host="localhost" port=8070]
//Context ctxtrolley ip[host="127.0.0.1" port=8052]

QActor client context ctxparkmanager {
	[# var TOKENID = ""
	 var SLOTNUM = 0  #]
	State s0 initial {
		println("Starting Client.")
	}
	Goto requestIn
	
	State requestIn {
		println("Client request to park.")
		request park_manager_service -m clientRequest : clientRequest(in)
	}
	Transition t0 whenReply enter -> handleSlotnum
		
	State handleSlotnum {
		onMsg( enter : enter(SLOTNUM)) {
			[# SLOTNUM = payloadArg(0).toInt() #]
			println("received slotnum: $SLOTNUM")
		} 
	}
	Goto end if [# SLOTNUM==0 #] else moveIndoor
	
	State moveIndoor {
		request park_manager_service -m carenter : carenter($SLOTNUM)	
	}
	Transition t0 whenReply replyTokenid -> handleTokenid
	
	State handleTokenid {
		printCurrentMessage
		onMsg( replyTokenid : replyTokenid(TOKEN)) {
			[# TOKENID = "${payloadArg(0)}" #]
			println("received tokenid: $TOKENID")
		}
	}
	Transition out whenTime 1000 -> requestOut
	
	State requestOut {
		println("Client request to exit sent.")
		forward park_manager_service -m outTokenid : outTokenid($TOKENID) 
	}
	Goto end

	State end {
		println("Client finished")
	}
} 

QActor park_manager_service context ctxparkmanager {
	[# var counter=0 #]
	State s0 initial {
		discardMsg Off
		solve( consult("parking.pl"))
		solve( dynamic("freeSlot/1") )
		solve(unoccupySlot(1))
		println("Starting ParkManagerService.")
	}
	Goto accept
	
	State accept {
		println("ParkManagerServing accepting client requests...")	
	}
	Transition clientMsg whenRequest clientRequest -> handleClientRequest
						 whenRequest carenter -> handleCarEnter
						 whenMsg outTokenid -> handleClientOut
	
	State handleClientRequest {
		println("ParkManagerService handeling client request")
		onMsg( clientRequest : clientRequest(X)) {
			[# val requestType = "${payloadArg(0)}" #]
			if [# requestType == "in" #] {
				println("ParkManagerServing Request to park received.")
				
				//verifica se INDOOR è libero
				//verifica stato del robot
				
				solve( getFreeSlot( S ) )
				[# val SLOTNUM = getCurSol("S") #] 
				solve( occupySlot( $SLOTNUM ) ) //se poi non fa carenter? occuparlo dopo? se poi lo do ad un altra macchina?
				
				replyTo clientRequest with  enter :  enter( $SLOTNUM )
			}
		}
	}
	Goto accept
	
	State handleCarEnter {
		printCurrentMessage
		onMsg(carenter : carenter(SLOTNUM)) {
			[# val SLOTNUM = payloadArg(0).toInt() #]
			
			//muovi trolley
			
			solve( getCoordinates($SLOTNUM,X,Y) )
			[# val x = getCurSol("X") #]
			[# val y = getCurSol("Y") #]
			println("x: $x, y: $y")
			//forward mytrolley -m move : move(x,y)
					
			[# val TOKENID = "$SLOTNUM,$counter" #]
			[# counter++ #]
					
			replyTo carenter with  replyTokenid :  replyTokenid( $TOKENID )
		}
	}
	Goto accept
	
	State handleClientOut {
		println("ParkManagerServing out.")
		
		//verifica OUTDOOR free
		//verifica stato trolley
		
		onMsg( outTokenid : outTokenid(X)) {
			[# val TOKENID = "${payloadArg(0)}" #]
			[# val SLOTNUM =  TOKENID.split(",")[0] #]
			
			solve( outdoor(X,Y) )
			[# val x = getCurSol("X") #]
			[# val y = getCurSol("Y") #]
			println("x: $x, y: $y")
			
			//forward mytrolley -m move : move(x,y)
			
			solve( unoccupySlot( $SLOTNUM ) ) 
			
			println("$SLOTNUM")	
			//muovi trolley
		}
	}
	Goto accept
	 
}


/* 
QActor weight_sensor context ctxParkManagerService {
	[#   
		var prevWeight=0f
		
		fun resourceInfo(weight: Float, preWeight: Float) : String {
			if (Math.abs(weight - prevWeight) > 10) {
				if (weight.toInt() == 0) {
					return "free"
				}
 			}
 			return "occupied"
 		}
	#]
	
	State s0 initial {
		println("Starting Weight sensor.")
	}
	Goto wait
	
	State wait {
		println("Weightsensor waiting for data...")
	}
	Transition data whenMsg weightData -> handleData
	
	State handleData {
		println("Weightsensor received data")
		onMsg(weightData : weightData(W)) {
			[# var weight = "${payloadArg(0)}" #]
			println("weight: $weight")
			updateResource [# resourceInfo(weight.toFloat(), prevWeight.toFloat()) #]
			[# prevWeight = weight.toFloat() #]
		}
	}
	Goto wait
	
}

QActor weight_mock context ctxParkManagerService {
	State s0 initial {
		println("Starting WeightMock")
	} Goto sendData
	
	State sendData {
		forward weight_sensor -m weightData : weightData(50)
		
		delay 5000
		
		forward weight_sensor -m weightData : weightData(45)
		
		delay 5000
		
		forward weight_sensor -m weightData : weightData(0)
		
		delay 5000
		
		forward weight_sensor -m weightData : weightData(80)
		
		delay 5000
		
		forward weight_sensor -m weightData : weightData(0)
	}
}

QActor transport_trolley context ctxParkManagerService {
	
	[#
		val mapname     = "parkingMap"  		 
		var Myself      = myself   
		var CurrentPlannedMove = "" 
		var x = ""
		var y = ""
	#]
	
	State s0 initial {
		run itunibo.planner.plannerUtil.initAI()
		run itunibo.planner.plannerUtil.loadRoomMap("$mapname") 
		run itunibo.planner.plannerUtil.showMap( )   
     	run itunibo.planner.plannerUtil.showCurrentRobotState()
     	
     	run pathexecutil.register( Myself )
	}
	Goto wait
	
	State wait {
		println("Waiting messages...")
	}
	Transition t0 whenMsg move -> handle
	
	State handle {
		printCurrentMessage
		onMsg(move : move(X,Y)) {
			[# 
				x = payloadArg(0)
				y = payloadArg(1)
			#]
			println("x: $x, y: $y")
			run itunibo.planner.plannerUtil.planForGoal(x,y)
		}
	}
	Goto execPlannedMoves     
    
	State execPlannedMoves{   
		delay 300
 		[#  CurrentPlannedMove = itunibo.planner.plannerUtil.getNextPlannedMove() #]
 		println("+++++++++++++++++++++++++++++++ $CurrentPlannedMove")
 	}
 	Goto doMove if [# CurrentPlannedMove.length>0 #] else parkthecar
 
 	State doMove{ 		
 	}
 	Goto wMove if [# CurrentPlannedMove == "w" #] else turnMove
 	
 	State wMove {     
 		qrun pathexecutil.doMove(myself, "p" )  
 	}
 	Transition t0 whenMsg moveok   -> stepDone   
  	
 	 State stepDone{  
 	 	printCurrentMessage
 		//updateResource [# itunibo.planner.plannerUtil.getMap() #]
 		run itunibo.planner.plannerUtil.updateMap(  "w" )
 		run itunibo.planner.plannerUtil.showCurrentRobotState( )
 		//updateResource [# "stepDone" # ]
  	} 
 	Goto execPlannedMoves
 	
 	State turnMove{
 		println("-----qqqq-----------------dsaasds---------------sdaadssdasdassdadsd - -- -$CurrentPlannedMove")
  		if [# CurrentPlannedMove == "l" || CurrentPlannedMove == "r"  #]{
  			qrun pathexecutil.doMove(myself, "$CurrentPlannedMove")
  		} 
 	}   
  	Transition t0  whenMsg moveok   -> rotationDone


 	State rotationDone{
 		run itunibo.planner.plannerUtil.updateMap(  "$CurrentPlannedMove" )
   		//run itunibo.planner.plannerUtil.showCurrentRobotState( )
 	} 
 	 Goto execPlannedMoves
 	
 	State parkthecar{
 		printCurrentMessage
 		run itunibo.planner.plannerUtil.showCurrentRobotState( )  
 		if [# ! itunibo.planner.plannerUtil.atPos(x.toInt(),y.toInt()) #]{
 			run itunibo.planner.plannerUtil.planForGoal(x,y)
 		}
 		else{
 			run itunibo.planner.plannerUtil.planForGoal("0","0")
 		}
 	}
    Goto execPlannedMoves  if[# ! itunibo.planner.plannerUtil.atHome() #] else  wait
	
}
* */